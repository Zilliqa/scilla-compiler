Closure converted AST:
fundef ($fundef_2 : [Bool] -> Int32) ((c : Bool) : Bool)
environment: ((x : Int32) : Int32 , (y : Int32) : Int32)
body:
  (x : Int32) <- [($fundef_2 : [Bool] -> Int32)]((x : Int32))
  (y : Int32) <- [($fundef_2 : [Bool] -> Int32)]((y : Int32))
  decl ($retval_3 : Int32)
  match (c : Bool) with
  | True =>
    ($retval_3 : Int32) = (x : Int32)
  | _ =>
    jump ($joinp_0 : Int32)
  join ($joinp_0 : Int32) =>
    ($retval_3 : Int32) = (y : Int32)
  ret ($retval_3 : Int32)

expr_body:
  decl ($expr_1 : [Bool] -> Int32)
  decl (x : Int32)
  (x : Int32) = (Int32 42)
  decl (y : Int32)
  (y : Int32) = (Int32 41)
  decl (f : [Bool] -> Int32)
  allocate_closure_env ($fundef_2 : [Bool] -> Int32)
  [($fundef_2 : [Bool] -> Int32)]((x : Int32)) <- (x : Int32)
  [($fundef_2 : [Bool] -> Int32)]((y : Int32)) <- (y : Int32)
  (f : [Bool] -> Int32) = [($fundef_2 : [Bool] -> Int32)]
  ($expr_1 : [Bool] -> Int32) = (f : [Bool] -> Int32)
  ret ($expr_1 : [Bool] -> Int32)

Type specialized ADTS:
Bool:
  

LLVM module:
; ModuleID = 'scilla_expr'
source_filename = "scilla_expr"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

%Int32 = type { i32 }
%"$$fundef_2_env_4" = type { %Int32, %Int32 }
%Bool = type { i8, %True*, %False* }
%True = type <{ i8 }>
%False = type <{ i8 }>

define %Int32 @"$fundef_2"(%"$$fundef_2_env_4"*, %Bool*) {
entry:
  %"$$fundef_2_env_x_5" = getelementptr inbounds %"$$fundef_2_env_4", %"$$fundef_2_env_4"* %0, i32 0, i32 0
  %"$x_envload_6" = load %Int32, %Int32* %"$$fundef_2_env_x_5"
  %x = alloca %Int32
  store %Int32 %"$x_envload_6", %Int32* %x
  %"$$fundef_2_env_y_7" = getelementptr inbounds %"$$fundef_2_env_4", %"$$fundef_2_env_4"* %0, i32 0, i32 1
  %"$y_envload_8" = load %Int32, %Int32* %"$$fundef_2_env_y_7"
  %y = alloca %Int32
  store %Int32 %"$y_envload_8", %Int32* %y
  %"$retval_3" = alloca %Int32
  %"$c_tag_11" = getelementptr inbounds %Bool, %Bool* %1, i32 0, i32 0
  %"$c_tag_12" = load i8, i8* %"$c_tag_11"
  switch i8 %"$c_tag_12", label %"$default_13" [
    i8 0, label %"$True_14"
  ]

"$True_14":                                       ; preds = %entry
  %"$c_15" = bitcast %Bool* %1 to %True*
  %"$x_16" = load %Int32, %Int32* %x
  store %Int32 %"$x_16", %Int32* %"$retval_3"
  br label %"$matchsucc_9"

"$default_13":                                    ; preds = %entry
  br label %"$joinp_0"

"$joinp_0":                                       ; preds = %"$default_13"
  %"$y_10" = load %Int32, %Int32* %y
  store %Int32 %"$y_10", %Int32* %"$retval_3"
  br label %"$matchsucc_9"

"$matchsucc_9":                                   ; preds = %"$True_14", %"$joinp_0"
  %"$$retval_3_17" = load %Int32, %Int32* %"$retval_3"
  ret %Int32 %"$$retval_3_17"
}

define { %Int32 (void*, %Bool*)*, void* } @"$scilla_expr_18"(void*) {
entry:
  %"$expr_1" = alloca { %Int32 (void*, %Bool*)*, void* }
  %x = alloca %Int32
  store %Int32 { i32 42 }, %Int32* %x
  %y = alloca %Int32
  store %Int32 { i32 41 }, %Int32* %y
  %f = alloca { %Int32 (void*, %Bool*)*, void* }
  %malloccall = tail call i8* @malloc(i32 trunc (i64 mul nuw (i64 ptrtoint (i32* getelementptr (i32, i32* null, i32 1) to i64), i64 2) to i32))
  %"$$fundef_2_envp_19" = bitcast i8* %malloccall to %"$$fundef_2_env_4"*
  %"$$fundef_2_env_voidp_21" = bitcast %"$$fundef_2_env_4"* %"$$fundef_2_envp_19" to void*
  %"$$fundef_2_cloval_22" = insertvalue { %Int32 (void*, %Bool*)*, void* } { %Int32 (void*, %Bool*)* bitcast (%Int32 (%"$$fundef_2_env_4"*, %Bool*)* @"$fundef_2" to %Int32 (void*, %Bool*)*), void* undef }, void* %"$$fundef_2_env_voidp_21", 1
  %"$$fundef_2_envp_23" = extractvalue { %Int32 (void*, %Bool*)*, void* } %"$$fundef_2_cloval_22", 1
  %"$$fundef_2_envp_24" = bitcast void* %"$$fundef_2_envp_23" to %"$$fundef_2_env_4"*
  %"$$fundef_2_env_x_25" = getelementptr inbounds %"$$fundef_2_env_4", %"$$fundef_2_env_4"* %"$$fundef_2_envp_24", i32 0, i32 0
  %"$x_26" = load %Int32, %Int32* %x
  store %Int32 %"$x_26", %Int32* %"$$fundef_2_env_x_25"
  %"$$fundef_2_envp_27" = extractvalue { %Int32 (void*, %Bool*)*, void* } %"$$fundef_2_cloval_22", 1
  %"$$fundef_2_envp_28" = bitcast void* %"$$fundef_2_envp_27" to %"$$fundef_2_env_4"*
  %"$$fundef_2_env_y_29" = getelementptr inbounds %"$$fundef_2_env_4", %"$$fundef_2_env_4"* %"$$fundef_2_envp_28", i32 0, i32 1
  %"$y_30" = load %Int32, %Int32* %y
  store %Int32 %"$y_30", %Int32* %"$$fundef_2_env_y_29"
  store { %Int32 (void*, %Bool*)*, void* } %"$$fundef_2_cloval_22", { %Int32 (void*, %Bool*)*, void* }* %f
  %"$f_31" = load { %Int32 (void*, %Bool*)*, void* }, { %Int32 (void*, %Bool*)*, void* }* %f
  store { %Int32 (void*, %Bool*)*, void* } %"$f_31", { %Int32 (void*, %Bool*)*, void* }* %"$expr_1"
  %"$$expr_1_32" = load { %Int32 (void*, %Bool*)*, void* }, { %Int32 (void*, %Bool*)*, void* }* %"$expr_1"
  ret { %Int32 (void*, %Bool*)*, void* } %"$$expr_1_32"
}

declare noalias i8* @malloc(i32)


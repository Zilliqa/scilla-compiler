Closure converted AST:
fundef ($fundef_1 : [Int32] -> Int32) ((a : Int32) : Int32)
environment: ()
body:
  ($retval_2 : Int32) = (a : Int32)
  ret ($retval_2 : Int32)

expr_body:
  ($expr_0 : [Int32] -> Int32) = [($fundef_1 : [Int32] -> Int32)]
  ret ($expr_0 : [Int32] -> Int32)
LLVM module:
; ModuleID = 'scilla_expr'
source_filename = "scilla_expr"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

%"$$fundef_1_env_3" = type {}
%Int32 = type { i32 }

declare %Int32 @"$fundef_1"(%"$$fundef_1_env_3"*, %Int32)

define { %Int32 (void*, %Int32)*, void* } @"$scilla_expr_4"() {
entry:
  %"$expr_0" = alloca { %Int32 (void*, %Int32)*, void* }
  store { %Int32 (void*, %Int32)*, void* } { %Int32 (void*, %Int32)* bitcast (%Int32 (%"$$fundef_1_env_3"*, %Int32)* @"$fundef_1" to %Int32 (void*, %Int32)*), void* null }, { %Int32 (void*, %Int32)*, void* }* %"$expr_0"
  %"$$expr_0_7" = load { %Int32 (void*, %Int32)*, void* }, { %Int32 (void*, %Int32)*, void* }* %"$expr_0"
  ret { %Int32 (void*, %Int32)*, void* } %"$$expr_0_7"
}

